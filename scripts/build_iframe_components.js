#!/usr/bin/env node

/**
 * Build script for iframe-compatible React components.
 *
 * This script:
 * 1. Reads all .jsx files from app/javascript/iframe_components/
 * 2. Transforms them with Babel (JSX -> JS)
 * 3. Outputs a combined file to public/iframe_components.js
 *
 * The output file attaches all components to window.* for use in sandboxed iframes.
 * Components should use `const { useState, useEffect, ... } = React;` pattern
 * to use the global React instance loaded via CDN in the iframe.
 */

const fs = require("fs");
const path = require("path");
const babel = require("@babel/core");

const COMPONENTS_DIR = path.join(
  __dirname,
  "../app/javascript/iframe_components"
);
const OUTPUT_FILE = path.join(__dirname, "../public/iframe_components.js");
const MANIFEST_FILE = path.join(COMPONENTS_DIR, "manifest.json");

function buildComponents() {
  console.log("Building iframe components...\n");

  // Read manifest to get component order and metadata
  let manifest = { components: [] };
  if (fs.existsSync(MANIFEST_FILE)) {
    manifest = JSON.parse(fs.readFileSync(MANIFEST_FILE, "utf8"));
  }

  // Find all JSX files (excluding manifest.json)
  const files = fs
    .readdirSync(COMPONENTS_DIR)
    .filter((f) => f.endsWith(".jsx"));

  if (files.length === 0) {
    console.log("No .jsx files found in", COMPONENTS_DIR);
    return;
  }

  let output = `/**
 * Iframe Components Bundle
 * Auto-generated by scripts/build_iframe_components.js
 * 
 * These components are designed to work in sandboxed iframes that load React via CDN.
 * All components are attached to window.* and use the global React instance.
 * 
 * Generated: ${new Date().toISOString()}
 */

(function() {
  'use strict';
  
  // Ensure React is available
  if (typeof React === 'undefined') {
    console.error('iframe_components.js: React is not loaded. Make sure to load React before this script.');
    return;
  }

`;

  for (const file of files) {
    const componentName = path.basename(file, ".jsx");
    const filePath = path.join(COMPONENTS_DIR, file);
    const jsxCode = fs.readFileSync(filePath, "utf8");

    console.log(`  Compiling ${componentName}...`);

    try {
      // First, strip the export statement from the source before transforming
      let cleanedJsx = jsxCode.replace(
        /export\s+default\s+function/,
        "function"
      );

      // Transform JSX to JS
      const result = babel.transformSync(cleanedJsx, {
        presets: [["@babel/preset-react", { runtime: "classic" }]],
        plugins: [],
        filename: file,
      });

      let code = result.code;

      // Remove any "use strict" that Babel might add (we add our own at the top)
      code = code.replace(/"use strict";\s*/g, "");

      // Clean up any leading/trailing whitespace
      code = code.trim();

      output += `  // ============ ${componentName} ============\n`;
      output += `  ${code}\n`;
      output += `  window.${componentName} = ${componentName};\n\n`;
    } catch (error) {
      console.error(`  Error compiling ${file}:`, error.message);
      process.exit(1);
    }
  }

  // Write output
  fs.writeFileSync(OUTPUT_FILE, output);
  console.log(`\n✓ Built ${files.length} component(s) to ${OUTPUT_FILE}`);

  // Also generate documentation string for the AI prompt
  generatePromptDocumentation(manifest);
}

function generatePromptDocumentation(manifest) {
  if (!manifest.components || manifest.components.length === 0) {
    return;
  }

  let docs =
    "Available global components you can use (no import needed, just use directly):\n\n";

  for (const comp of manifest.components) {
    docs += `- ${comp.name}: ${comp.description}\n`;
    docs += "  Props:\n";

    for (const prop of comp.props) {
      docs += `    - ${prop.name} (${prop.type}${
        prop.required ? ", required" : ", optional"
      }): ${prop.description}\n`;
      if (prop.itemShape) {
        for (const [key, desc] of Object.entries(prop.itemShape)) {
          docs += `      - ${key}: ${desc}\n`;
        }
      }
    }

    docs += `  Example: ${comp.example}\n\n`;
  }

  const docsFile = path.join(COMPONENTS_DIR, "prompt_documentation.txt");
  fs.writeFileSync(docsFile, docs);
  console.log(`✓ Generated prompt documentation to ${docsFile}`);
}

// Run initial build
buildComponents();

// Watch mode if --watch flag is passed
if (process.argv.includes("--watch")) {
  console.log("\nWatching for changes in", COMPONENTS_DIR, "...\n");

  let debounceTimer = null;

  fs.watch(COMPONENTS_DIR, { recursive: false }, (eventType, filename) => {
    if (
      !filename ||
      (!filename.endsWith(".jsx") && !filename.endsWith(".json"))
    )
      return;

    // Debounce rapid changes
    if (debounceTimer) clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
      console.log(
        `\n[${new Date().toLocaleTimeString()}] Change detected in ${filename}`
      );
      try {
        buildComponents();
      } catch (error) {
        console.error("Build failed:", error.message);
      }
    }, 100);
  });
}
